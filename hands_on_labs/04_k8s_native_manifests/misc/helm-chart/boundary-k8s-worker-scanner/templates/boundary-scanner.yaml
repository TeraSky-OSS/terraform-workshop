# Retrieve Secrets for the Boundary Cluster Access
---
apiVersion: {{ .Values.secretStoreAPIVersion}}
kind: SecretProviderClass
metadata:
  name: boundary-scanner-secrets-aws
  namespace: {{ .Values.namespace}}
spec:
  provider: aws
  parameters:
    objects: |
        - objectName: "{{ .Values.boundaryClusterUrlSecretName}}"
          objectType: "secretsmanager"
          objectAlias: "boundary_cluster_url"
        - objectName: "{{ .Values.boundaryWorkerCredsSecretName}}"
          objectType: "secretsmanager"
          jmesPath:
            - path: auth_method_id
              objectAlias: boundary_auth_method_id
        - objectName: "{{ .Values.boundaryAdminCredsSecretName}}"
          objectType: "secretsmanager"
          jmesPath:
            - path: username
              objectAlias: boundary_scanner_username
            - path: password
              objectAlias: boundary_scanner_password
        - objectName: "{{ .Values.boundaryScopeIdSecretName}}-{{ .Values.environment}}"
          objectType: "secretsmanager"
          jmesPath:
            - path: scope_id
              objectAlias: boundary_scope_id
  secretObjects:
    - secretName: boundary-cluster-scanner
      type: Opaque
      data:
        - objectName: boundary_cluster_url
          key: BOUNDARY_ADDR
        - objectName: boundary_scope_id
          key: BOUNDARY_SCOPE_ID
    - secretName: boundary-scanner-auth
      type: Opaque
      data:
        - objectName: "boundary_auth_method_id"
          key: BOUNDARY_AUTH_METHOD_ID
        - objectName: "boundary_scanner_username"
          key: BOUNDARY_AUTHENTICATE_PASSWORD_LOGIN_NAME
        - objectName: "boundary_scanner_password"
          key: BOUNDARY_AUTHENTICATE_PASSWORD_PASSWORD
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::{{ .Values.awsAccount | toString }}:role/{{ .Values.eksClusterName}}-boundary-scanner
  name: boundary-scanner
  namespace: {{ .Values.namespace}}
  labels:
    app.kubernetes.io/name: boundary-scanner
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: boundary-scan-apply-sh
  namespace: {{ .Values.namespace}}
  labels:
    app.kubernetes.io/name: boundary-scanner
data:
  boundary-scan-apply.sh: |
    #!/bin/sh
    set -e
    FILE=terraform.tfvars
    cd /scripts
    # Boundary env vars generated from secrets automatically
    echo "Generating $FILE"
    truncate -s 0 $FILE
    cat <<EOF >>$FILE
    boundary_cluster_url    = "$BOUNDARY_ADDR"
    boundary_auth_method_id = "$BOUNDARY_AUTH_METHOD_ID"
    boundary_username       = "$BOUNDARY_AUTHENTICATE_PASSWORD_LOGIN_NAME"
    boundary_password       = "$BOUNDARY_AUTHENTICATE_PASSWORD_PASSWORD"
    boundary_scope_id       = "$BOUNDARY_SCOPE_ID"
    env                     = "{{.Values.environment}}"
    plugin_tcp_targets = [
    {{- range $target := .Values.boundaryPluginTcpTargets }}
        {
        app = "{{ $target.app }}"
        namespace = "{{ $target.namespace }}"
        {{- if $target.port }}
        port = "{{ $target.port }}"
        {{- end }}
        },
    {{- end }}
    ]
    EOF
    # Run Terraform file - boundary-scan-create-targets.tf Job in a loop
    echo "Scanning And Applying Boundary Targets Using Terraform" 
    terraform init && terraform apply --auto-approve
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: boundary-scan-create-targets-tf
  namespace: {{ .Values.namespace}}
  labels:
    app.kubernetes.io/name: boundary-scanner
data:
  boundary-scan-create-targets.tf: |
    provider "boundary" {
        addr                            = var.boundary_cluster_url
        auth_method_id                  = var.boundary_auth_method_id
        password_auth_method_login_name = var.boundary_username
        password_auth_method_password   = var.boundary_password
    }

    terraform {
        required_providers {
        boundary = {
            source = "hashicorp/boundary"
            version = "1.1.4"
            }
        kubernetes = {
            source  = "hashicorp/kubernetes"
            version = "2.18.1"
            }
        curl = {
            source  = "anschoewe/curl"
            version = ">= 1.0.2"
            }
        }
    }

    terraform {
        backend "s3" {
            bucket = "{{ .Values.scannerS3BucketName }}"
            key    = "tfstate"
            region = "{{ .Values.awsRegion}}"
        }
    }

    provider "kubernetes" {
    }

    # Variables
    variable "boundary_cluster_url" {
        type = string
        description = "Boundary cluster URL"
    }

    variable "boundary_auth_method_id" {
        type = string
        description = "Boundary auth method ID"
    }

    variable "boundary_username" {
        type = string
        description = "Boundary username"
    }

    variable "boundary_password" {
        type = string
        description = "Boundary password"
    }

    variable "env" {
        type = string
        description = "Environment"
    }

    variable "boundary_scope_id" {
        type = string
        description = "Boundary scope ID"
    }

    variable "plugin_tcp_targets" {
        type = list(object({
        app = string
        namespace = string
        port = optional(string)
        }))
        description = "List of TCP targets to scan"
        default = []
    }

    # Scan K8S Services
    data "kubernetes_service" "k8s_services" {
    for_each = { for target in var.plugin_tcp_targets : "${target.app}" => target if var.plugin_tcp_targets != null }
    metadata {
        name      = each.value.app
        namespace = each.value.namespace
        }
    }

    locals {
      targets_with_ports = var.plugin_tcp_targets != null ? {
        for target in var.plugin_tcp_targets :
        target.app => {
          port = can(target.port) ? target.port : null
        }
      } : null
    }

    # Set Up Boundary Targets - K8S Services
    resource "boundary_target" "target_tcp_plugin" {
      for_each             = { for service in data.kubernetes_service.k8s_services : "${service.metadata[0]["name"]}" => service
                            if data.kubernetes_service.k8s_services != null && service.id != null }
      name                 = "${each.value.metadata[0]["name"]}-${var.env}"
      address              = "${each.value.metadata[0]["name"]}.${each.value.metadata[0]["namespace"]}.svc.cluster.local"
      description          = "The Target for the app ${each.value.metadata[0]["name"]}"
      type                 = "tcp"
      default_port         = local.targets_with_ports[each.value.metadata[0]["name"]].port != null ? local.targets_with_ports[each.value.metadata[0]["name"]].port : "${each.value.spec[0].port[0]["port"]}"
      scope_id             = var.boundary_scope_id
      egress_worker_filter = "(\"egress\" in \"/tags/type\" and \"${var.env}\" in \"/tags/environment\")"
    }
---
# apiVersion: apps/v1
# kind: Deployment
# metadata:
#   namespace: {{ .Values.namespace}}
#   name: boundary-scanner-{{ .Values.environment}}
#   labels:
#     app.kubernetes.io/name: boundary-scanner
# spec:
#   replicas: 1
#   selector:
#     matchLabels:
#       app.kubernetes.io/name: boundary-scanner
#   template:
#     metadata:
#       labels:
#         app.kubernetes.io/name: boundary-scanner
#     spec:
#       serviceAccountName: boundary-scanner
#       volumes:
#       - name: boundary-scanner-secrets-aws
#         csi:
#           driver: secrets-store.csi.k8s.io
#           readOnly: true
#           volumeAttributes:
#             secretProviderClass: boundary-scanner-secrets-aws
#       - name: scripts
#         emptyDir:
#           medium: Memory
#       - name: boundary-scan-apply-sh
#         configMap:
#           name: boundary-scan-apply-sh
#       - name: boundary-scan-create-targets-tf
#         configMap:
#           name: boundary-scan-create-targets-tf
#       containers:
#       - name: boundary-scanner
#         image: hashicorp/terraform:1.4
#         ports:
#         - containerPort: 9202
#         command: ["sh", "/scripts/boundary-scan-apply.sh"]
#         envFrom:
#         - secretRef:
#             name: boundary-scanner-auth
#         - secretRef:
#             name: boundary-cluster-scanner
#         volumeMounts:
#         - name: boundary-scanner-secrets-aws
#           mountPath: "/boundary-scanner-secrets-aws"
#           readOnly: true
#         - name: "scripts"
#           mountPath: "/scripts"
#         - name: "boundary-scan-create-targets-tf"
#           mountPath: "/scripts/boundary-scan-create-targets.tf"
#           readOnly: true
#           subPath: boundary-scan-create-targets.tf
#         - name: "boundary-scan-apply-sh"
#           mountPath: "/scripts/boundary-scan-apply.sh"
#           readOnly: true
#           subPath: boundary-scan-apply.sh
#         resources:
#           requests:
#             memory: "256Mi"
#             cpu: "500m"
#           limits:
#             memory: "256Mi"
#             cpu: "500m"
#         # readinessProbe:
#         #   tcpSocket:
#         #     port: 9202
#         #   initialDelaySeconds: 5
#         #   periodSeconds: 10
#         # livenessProbe:
#         #   tcpSocket:
#         #     port: 9202
#         #   initialDelaySeconds: 15
#         #   periodSeconds: 20
apiVersion: batch/v1
kind: CronJob
metadata:
  name: boundary-scanner-{{ .Values.environment}}
  namespace: {{ .Values.namespace}}
  labels:
    app.kubernetes.io/name: boundary-scanner
spec:
  schedule: "*/{{ .Values.scanInterval}} * * * *" # Will restart every 1 and a half minutes
  successfulJobsHistoryLimit: {{ .Values.successfulJobsHistoryLimit}}
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 5
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app.kubernetes.io/name: boundary-scanner
        spec:
          restartPolicy: OnFailure
          serviceAccountName: boundary-scanner
          volumes:
          - name: boundary-scanner-secrets-aws
            csi:
              driver: secrets-store.csi.k8s.io
              readOnly: true
              volumeAttributes:
                secretProviderClass: boundary-scanner-secrets-aws
          - name: scripts
            emptyDir:
              medium: Memory
          - name: boundary-scan-apply-sh
            configMap:
              name: boundary-scan-apply-sh
          - name: boundary-scan-create-targets-tf
            configMap:
              name: boundary-scan-create-targets-tf
          containers:
          - name: boundary-scanner
            image: hashicorp/terraform:1.4
            ports:
            - containerPort: 9202
            command: ["sh", "/scripts/boundary-scan-apply.sh"]
            envFrom:
            - secretRef:
                name: boundary-scanner-auth
            - secretRef:
                name: boundary-cluster-scanner
            volumeMounts:
            - name: boundary-scanner-secrets-aws
              mountPath: "/boundary-scanner-secrets-aws"
              readOnly: true
            - name: "scripts"
              mountPath: "/scripts"
            - name: "boundary-scan-create-targets-tf"
              mountPath: "/scripts/boundary-scan-create-targets.tf"
              readOnly: true
              subPath: boundary-scan-create-targets.tf
            - name: "boundary-scan-apply-sh"
              mountPath: "/scripts/boundary-scan-apply.sh"
              readOnly: true
              subPath: boundary-scan-apply.sh
            resources:
              requests:
                memory: "256Mi"
                cpu: "500m"
              limits:
                memory: "256Mi"
                cpu: "500m"
